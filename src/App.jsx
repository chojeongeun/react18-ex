import Post from './Post';
import { Suspense } from 'react';

function App() {
	return (
		<div className='App'>
			<h1>App</h1>
			{/* Suspense로 특정 컴포넌트 그룹을 묶으면 해당 그룹만 동기화 처리 */}
			<Suspense fallback={<p>Posts loading...</p>}>
				<h1>Posts</h1>
				<Post />
			</Suspense>
		</div>
	);
}

export default App;
/*
  Automatic Batching
  : 핸들러 함수 안쪽에서 복수개의 state값이 변경될때 해당 변경사항을 묶어서 (batching)해서 한번만 리랜더링
  : 기존의 17버전에서는 promise를 반환하는 함수 안에서는 auto batching 동작 불가 (18버전에서 개선)

	useTransition
	: 컴포넌트 렌더링시 연산의 우선순위를 둬서 좀 늦게 렌더링해도 될 것들을 지정
	: 기존에는 한번 렌더링 연산이 시작되면 중간에 멈출 수 없었음
	: 문제 - 특정 핸들러 함수에 의해서 화면을 재연산해야되는 경우 중간에 무거운 로직이 실행되는 연산이 있으면 나머지 연산도 같이 지연이 일어남
	
	기존의 CSR, SSR방식 차이
	-예전의 SSR 작업 흐름
		1. 정적인 HTML파일을 서버로부터 가져옴
		2. 추후 동적 데이터가 필요할때마다 다시 서버쪽에 요청해서 전체 화면을 full load (화면 깜박임)
		3. 이후 ajax라는 비동기 서버 통신 기술이 생기면서 전체 화면을 다시 full load하지 않고 필요한 데이터만 실시간으로 다시 호출 가능
		4. 단점: 비동기 데이터를 이용해 자바스크립트로 일일이 동적 돔을 생성하고 관리해야되는 번거로움이 생김

	-CSR 작업 흐름
	1. 빈 HTML 파일을 서버로부터 가져옴
	2. 자바스크립트 파일로드 (react)
	3. 리액트 컴포넌트 로드 (Data fetching)
	4. 컴포넌트 해석 후 렌더링 시작
	5. 최종화면에 동적 DOM 생성 (이전 단게까지는 빈 화면 렌더링)

	-React18버전에서의 SSR 작업 흐름
	1. 서버쪽에서 미리 static 프리랜더링된 html파일 로드
	2. 미리 랜더링된 정적인 화면을 바로 생성 (정적 화면 생성)
	3. 자바스크립트 파일 로드
	4. 동적 데이터를 다루는 리액트 컴포넌트를 해석
	5. 기존 정적인 화면에 동적으로 연결된 부분만 대체 (hydration) Suspense활용

	-React18에서의 Suspense
		- 각 페이지에 구성되어있는 컴포넌트들을 동시에 호출하는 것이 아닌 영역별로 렌더링 시점을 동기화 처리
		- 이전 버전까지는 클라이언트 컴포넌트에서만 제한적으로 동작되는 기술이였으나 18버전부터는 SSR방식의 컴포넌트에서도 활용가능하도록 개선
		- 활용예 : 특정 컴포넌트가 렌더링 완료될때까지 다른 컴포넌트의 렌더링을 막고 이전 렌더링 컴포넌트 완료 후 동기적으로 렌더링 시작
		- 활용예 : 서버로부터 무거운 데이터를 fetching하는 컴포넌트의 경우 해당 컴포넌트 출력 전까지 자동으로 로딩바 출력
		- suspense를 활용하기 위한 조건 : suspense동기화시키는 컴포넌트 내부에 promise객체 생성 상태(pending, fullfilled, rejected)를 추적할 수 있어야됨
*/
